程序：数据结构 + 算法
算法1：公用的算法
    2：自己优化程序时写的算法

算法学习的说明：1 快排，理解并可以使用到程序，优化代码，解决一个问题
               2 自己要创造一个算法


数据结构画图理解 ---  结合图

数据结构分两大类：
    线性结构（一维数组，队列，链表，栈） 一一对应
    非线性结构（二维数组，多维数组，广义表，数，深林，图）

一、数组

二、队列：先进先出
 需要两个变量 front  rear  分别记录队列的前后端的下标

 小结：
 1 队列是有序列表
 2 front初始化为-1，表示队列的头，但是约定不包含头元素，即指向行队列的第一个元素的前一个位置
 3 rear初试-1，指向队列的尾部，包含最后一个元素
 4 判断队列空  front == rear 表示空
 5 判断队列满  rear == maxSize-1



队列的优化
将队列当作一个环形队列使用的思路【取模】
1 仍然使用front rear约定，但是含义会发生变化
2 将front初始化为0 ，front就指向队列的第一个元素
3 将rear初始化为0，rear指向的是队列的最后一个元素的 后一个位置
《即整体后移一位》
4 通过取%将队列当做 环形，
    判断空 front == rear
    判断满的条件就是 (rear+1)%maxSize = front
        +1的原因是预留了一个空间作为约定【画图理解】


应用场景：
排队取号


三、链表（Linked List）
链表是学习  数 森林  图 的基础

链表在内存中不是连续分布的

优点：插入 删除 很快
缺点：检索很慢
=> 树结构（AVL,红黑树）都很快


单链表：
head节点，一般作用就是让程序员，定位这个链表，因此不放数据

说明：每一个节点都是一个对象

修改一个节点：
    思路
        编号不能变
        先找到节点，我们就替代给节点的name,namenick
        如果找不到，给出提示

删除节点思路：
    temp指向要删除的这个节点的前一个节点
    temp.next = temp.next.next

按照编号的位置添加
    1使用temp辅助，定位要添加的节点的前一个位置，即将新的节点，添加到temp后面
    2 指向下面的代码即可
        newNode.next  = temp.next
        temp.next = newNode




class HeroNOde{
 val no
 var name
 var next //指向下一个结点
 var pre //指向上一个结点
 }

 tail


双向链表
    优势：1 实现自我删除
         2 从前 从后 进行 遍历







class Boy{
val no
var next:Boy
}
n=5
k=2 从第2个小孩开始数数
m=2 数到第二个小孩出圈

环形链表
        约瑟夫问题 -- 丢手绢问题

  形成：一个环形链表的思路
    1 第一个小孩就是一个最初的环形链表
    2 第二个小孩，curBoy = first
    3 加入到环形链表 curBoy.next = boy   boy.next = first  curBpy = boy
    4 后边的继续添加小孩就重复3
  遍历环形链表的思路
    1 辅助指针curBoy = first
    2 while循环，输出curBoy的值，直到corBoy.next= first 结束

  删除节点：
  小孩数数数到自己，就出圈的思路
    第一种方式
      1 创建一个辅助指针 helper
      2 让helper移动到 first的 上一个
      3 让 first 移动 k-1个位置  同时 helper 也做相应的移动
      4 让 first 和 helper在移动 m-1个位置
      5 first就只想了 要删除的小孩
       first = first.next  helper.next = first
      6 重复 4  5，直到圈中只有一个小孩  first == helper



栈：

应用：
   子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
   处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
   表达式的转换与求值(实际解决)。
   二叉树的遍历。
   图形的深度优先(depth一first--search)搜索法


数组模拟栈
   创建一个数组。用于存放栈的数据
   定义一个栈顶top，初始化就是-1，提示top直接指向栈顶
   栈满 top == maxSize -1
   栈空 top == -1
   栈的常规操作
    出栈 pop: val res = arr(top) ,top -=1 返回res
    入栈 push： top += 1 arr(top) = num

链表模拟栈



递归：
    递归调用的规则：
    1 当程序执行一个方法时，就会开一个新的空间，该空间是独立的  ---  也可以指向同一个共享空间
    2 当一个独立空间的代码执行完毕时，或者遇到return，就会退出
    3 如果我们写一个递归，则我们的递归条件，要指向退出栈的方向，否则出现栈溢出

迷宫问题（递归回溯）的解决思路
    1 创建迷宫，使用二维数组map（8）7
    2 规定：二维数组 元素的值， 0 表示没有走过  1  表示墙  2 表示经过探测，是通路
                              3 经过探测，发现是死路
    3 当map（6）5表示小球  找到通路，这时就可以退出递归
    4 小球找到通路时，需要事先确定一个策略，下--右--上--左（策略很多，延伸为最短路径，，这里先理解，以后最短路径有专门的算法）






